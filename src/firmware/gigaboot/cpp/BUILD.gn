# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/board.gni")
import("//build/images/vboot/vboot.gni")
import("//src/firmware/gigaboot/cpp/backends.gni")
import("//zircon/kernel/phys/efi/efi_executable.gni")

config("board_name") {
  cflags = [ "-DBOARD_NAME=\"${board_name}\"" ]
}

source_set("lib") {
  sources = [
    "acpi.cc",
    "acpi.h",
    "boot_zbi_items.cc",
    "boot_zbi_items.h",
    "cmdline.cc",
    "cmdline.h",
    "device_path.cc",
    "device_path.h",
    "efi_variables.cc",
    "efi_variables.h",
    "fastboot.cc",
    "fastboot.h",
    "gbl_dt.cc",
    "gbl_efi_fastboot_protocol.cc",
    "gbl_efi_fastboot_protocol.h",
    "gbl_loader.cc",
    "gbl_loader.h",
    "gpt.cc",
    "gpt.h",
    "input.cc",
    "input.h",
    "mdns.cc",
    "mdns.h",
    "network.cc",
    "network.h",
    "partition.cc",
    "partition.h",
    "tss2_uefi.cc",
    "tss2_uefi.h",
    "utils.cc",
    "utils.h",
  ]

  public_deps = [
    "//sdk/lib/fit",
    "//sdk/lib/zbi-format",
    "//src/firmware/gigaboot/lib:bootbyte",
    "//src/firmware/gigaboot/lib:inet",
    "//src/firmware/lib/fastboot:fastboot-base",
    "//src/firmware/lib/storage",
    "//src/firmware/lib/zbi:in_tree",
    "//src/firmware/lib/zircon_boot:in_tree",
    "//src/lib/utf_conversion",
    "//third_party/tpm2-tss:tss2-rc",
    "//third_party/tpm2-tss:tss2-sys",
    "//zircon/kernel/lib/efi",
    "//zircon/kernel/lib/efi/variable",
    "//zircon/kernel/phys/efi:main",
    "//zircon/kernel/phys/efi:protocol",
    "//zircon/system/ulib/ddk-platform-defs",
    "//zircon/system/ulib/fbl",
    "//zircon/system/ulib/pretty",
    "//zircon/third_party/ulib/cksum",
  ]

  include_dirs = [ "../include" ]

  if (is_kernel) {
    public_deps += [
      "//zircon/kernel/lib/ktl",
      "//zircon/kernel/lib/libc",
    ]

    include_dirs += [ "//" ]  # utf_conversion isn't a proper library.
  }

  # UEFI does not require aligned access
  defines = [ "FUCHSIA_FIRMWARE_STORAGE_BUFFER_ALIGNMENT=1" ]
  public_configs = [ ":board_name" ]
}

# Some dependency does not exist in non efi toolchain, which will cause gn
# preprocessing error.
if (is_efi_toolchain) {
  # Backend implementation for the NUC platform
  source_set("backends_nuc") {
    sources = [ "backends_nuc.cc" ]
    deps = [
      "legacy_c_gigaboot",
      "//zircon/system/public",
      "//zircon/system/ulib/fbl:fbl",
    ]
  }
}

# A template that assembles a gigaboot esp binary and hardcodes a given
# permanent attributes file to into it.
#
# Parameters
#
#   permanent_attributes_file (required)
#     [path] path label to the permanent attributes file
#   gbl (optional)
#     [path] path label to the GBL EFI app file. If provided, the generated image will be a
#     gigaboot to gbl boot app. TODO(b/368647237): Removed once fully switched to GBL
#   stop_in_fastboot (optional)
#     [bool] Whether the image is for installer use. If set to true, the GBL EFI app will always
#     stops in fastboot mode on boot. The flag is ignored if `gbl` is not given.
template("gigaboot_esp") {
  assert(defined(invoker.permanent_attributes_file))

  gbl = ""
  if (defined(invoker.gbl)) {
    gbl = invoker.gbl
  }

  # Action to generate source file containing various blobs.
  _action_name = target_name + "_convert_to_cc_action"
  action(_action_name) {
    script = "//src/firmware/gigaboot/cpp/blob.py"
    _out_path = "$target_gen_dir/$target_name/blob.cc"
    args = [
      rebase_path(invoker.permanent_attributes_file),
      rebase_path(_out_path, root_build_dir),
    ]
    inputs = [ invoker.permanent_attributes_file ]

    if (gbl != "") {
      args += [
        "--gbl",
        rebase_path(gbl, root_build_dir),
      ]
      inputs += [ gbl ]
    }

    outputs = [ _out_path ]
  }

  # A target that provides API to get the embedded data blob.
  _blob_target = target_name + "_blob"
  source_set(_blob_target) {
    # Use the source generated by the above action target.
    sources = get_target_outputs(":$_action_name")
    deps = [ ":$_action_name" ]
    if (is_kernel) {
      public_deps = [ "//zircon/kernel/lib/libc" ]
    }
  }

  _main_target = target_name + "_main"
  source_set(_main_target) {
    sources = [
      "fastboot_tcp.cc",
      "fastboot_tcp.h",
      "main.cc",
      "malloc.cc",
      "sysdeps.cc",
      "zircon_boot_ops.cc",
      "zircon_boot_ops.h",
    ]

    deps = [
      ":lib",
      "legacy_c_gigaboot",
      "//src/firmware/lib/zircon_boot:in_tree",
      "//src/lib/zbitl",
      "//zircon/kernel/lib/ktl",
      "//zircon/kernel/lib/libc",
      "//zircon/kernel/phys:boot-zbi",
      "//zircon/kernel/phys:symbolize",
      "//zircon/third_party/ulib/cksum",
      gigaboot_backends,
    ]

    cflags = [ "-DAVB_COMPILATION" ]

    _stop_in_fastboot =
        defined(invoker.stop_in_fastboot) && invoker.stop_in_fastboot

    defines = []

    # TODO(b/368647237): This is a temporary switch for enabling GBL boot in Gigaboot for test
    # and development. It will be removed once we fully migrate to GBL.
    if (gbl != "") {
      defines += [ "GIGABOOT_BOOT_GBL" ]
      if (_stop_in_fastboot) {
        defines += [ "GBL_STOP_IN_FASTBOOT" ]
      }
    }
  }

  _efi_target = target_name + "-efi"
  efi_executable(_efi_target) {
    deps = [
      ":$_blob_target",
      ":$_main_target",
    ]

    # The LTO toolchain currently fails due to undefined "__chkstk", even though
    # the function is defined in src/firmware/gigaboot/lib/stdlib.c. For now we
    # simply disable the variant.
    exclude_toolchain_tags = [ "lto" ]
  }

  esp(target_name) {
    output_name = target_name

    if (use_gigaboot) {
      gigaboot_target = ":$_efi_target($efi_toolchain)"
      gigaboot_bin = get_label_info("$gigaboot_target", "root_out_dir") + "/" +
                     get_label_info(gigaboot_target, "name") + ".efi"
      metadata = {
        images = [
          {
            label = get_label_info(":$target_name", "label_with_toolchain")
            archive = true
            bootserver_pave = [ "--bootloader" ]
            bootserver_pave_zedboot = [ "--bootloader" ]
            fastboot_flash = [ "fuchsia-esp" ]
            name = "${target_name}.esp"
            path = "${target_name}.esp.blk"
            type = "blk"
          },
        ]
      }
    }
  }
}

gigaboot_esp("fuchsia") {
  permanent_attributes_file = gigaboot_eng_permanent_attributes
  if (gigaboot_use_gbl) {
    gbl = gigaboot_gbl_efi_app
  }
}

if (gigaboot_userdebug_permanent_attributes != "") {
  gigaboot_esp("userdebug-esp") {
    permanent_attributes_file = gigaboot_userdebug_permanent_attributes
  }
}

if (gigaboot_user_permanent_attributes != "") {
  gigaboot_esp("user-esp") {
    permanent_attributes_file = gigaboot_user_permanent_attributes
  }
}

if (gigaboot_gbl_efi_app != "") {
  gigaboot_esp("gbl-installer") {
    permanent_attributes_file = gigaboot_eng_permanent_attributes
    gbl = gigaboot_gbl_efi_app
    stop_in_fastboot = true
  }
}
